{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"git_notes git_notes git configuration \ud83d\udc47 Git configuration allows you to personalize how Git works for you. It's like setting preferences for any other software. There's a command called git config that lets you set and view these settings. check your current configuration \u27a1\ufe0f git config --list configure email and name globally email id \u27a1\ufe0f git config --global user.email \"enter email id\" user name \u27a1\ufe0f git config --global user.name \"enter your name\" add notepad++ as a global text editor \u27a1\ufe0f git config --global core.editor notepad++ ssh key generation \ud83d\udc47 generating SSH keys is a crucial step for using Git over SSH to securely connect to remote repositories like GitHub or GitLab. ssh-keygen -t rsa -C \"enter email id\" ssh-keygen This is the command to generate the SSH key pair. -t ed25519 This specifies the key type. Ed25519 is a modern and secure option. You can use -t rsa -b 4096 for RSA keys if your Git provider requires it, but Ed25519 is generally preferred. -C \"your_email@example.com\" This adds a comment to your key with your email address. This is helpful for identification. command will generate two keys A private key (usually named id_rsa ) - This key should be kept confidential and never shared. A public key (usually named id_rsa.pub ) - You'll need to add this public key to your Git provider account. clone repository \ud83d\udc47 git clone command is your gateway to creating a local copy, or clone, of a remote Git repository. basic syntax \u27a1\ufe0f git clone [url] [directory_name] git clone https://github.com/chaitu-ycr/git_notes.git other options clone to a specific path git clone https://github.com/chaitu-ycr/git_notes.git <user_defined_repo_path> Clone a specific branch use the -b flag to specify a particular branch to clone instead of the default branch. git clone -b <branch_name> https://github.com/chaitu-ycr/git_notes.git <user_defined_repo_path> Clone with mirror. --mirror flag creates a local copy that reflects all branches and tags from the remote repository. This is useful for making a complete backup. git clone --mirror https://github.com/chaitu-ycr/git_notes.git Sparse clone --sparse flag creates a lightweight clone that downloads only the minimum information needed to checkout a specific commit. This can save disk space. git clone --sparse https://github.com/chaitu-ycr/git_notes.git git checkout \ud83d\udc47 git checkout command is a versatile tool in Git with several functionalities Switching Branches switch between different branches in your local repository git checkout <branch_name> Detaching the HEAD use the -d flag to detach the HEAD git checkout -d <branch_name> Creating a New Branch \u27a1\ufe0f git checkout -b <new_branch_name> Restoring a File \u27a1\ufe0f git checkout <commit_hash> <file_path> Checkout with Checkout Index Checkout all staged files \u27a1\ufe0f git checkout Checkout a specific staged file \u27a1\ufe0f git checkout <file_path> git branch \ud83d\udc47 Listing Branches \u27a1\ufe0f git branch show all remote tracking branches \u27a1\ufe0f git branch \u2013a list the branches with additional information \u27a1\ufe0f git branch \u2013v only show merged branches \u27a1\ufe0f git branch \u2013m Creating a New Branch \u27a1\ufe0f git checkout -b <new_branch_name> Deleting a Branch \u27a1\ufe0f git branch -d <branch_name> Renaming a Branch \u27a1\ufe0f git branch -m <old_branch_name> <new_branch_name> Merging Branches \u27a1\ufe0f git merge <branch_name> git fetch \ud83d\udc47 git fetch \u27a1\ufe0f downloads updates from a remote repository without merging them into your local working directory. command is essential for staying up-to-date in Git workflows. git fetch <remote> <branchname> Basic Fetch \u27a1\ufe0f git fetch origin Fetching Specific Branch \u27a1\ufe0f git fetch origin main Pruning Stale Tracking Branches \u27a1\ufe0f git fetch --prune origin Fetches from all configured remotes \u27a1\ufe0f git fetch --all Fetches only tags \u27a1\ufe0f git fetch --tags Limits the fetch to a specific number of commits \u27a1\ufe0f git fetch --depth=<number> Shows what would be fetched without making any changes \u27a1\ufe0f git fetch --dry-run git pull \ud83d\udc47 git pull command is a convenient shortcut that combines the functionality of git fetch and git merge in a single step. git pull [<remote>] [<branchname>] Basic Usage \u27a1\ufe0f git pull origin Specifying Branch \u27a1\ufe0f git pull origin main - It's generally a good practice to run git fetch first to see what changes are available before using git pull to avoid unintended merges. More Options --rebase \u27a1\ufe0f Rebases your local commits on top of the remote branch instead of creating a merge commit. This can lead to a cleaner commit history but can be risky if you've already shared your local branch. --force \u27a1\ufe0f Forces the merge even if there are local uncommitted changes. This can be dangerous and should be used with caution. --all \u27a1\ufe0f Fetches from all configured remotes. git add \ud83d\udc47 git add command is your gateway to including changes in your Git repository. It instructs Git to prepare specific files or directories for the next commit. Basic Usage \u27a1\ufe0f git add <filename> Adding Multiple Files Explicit Listing \u27a1\ufe0f git add file1.txt file2.txt file3.js Using Wildcards \u27a1\ufe0f git add *.txt Adding All Staged Changes \u27a1\ufe0f git add . Adding All Changes (Staged and Unstaged) \u27a1\ufe0f git add -A More Options -f \u27a1\ufe0f Forces adding files even if they are ignored by Git. Use with caution as it bypasses exclusion rules. -p \u27a1\ufe0f Patches the content of a file interactively, allowing line-by-line staging of changes. -u \u27a1\ufe0f Updates the index with only the latest changes in a file, effectively refreshing the staged content. create or add new files \u27a1\ufe0f git add <new filename> git status \ud83d\udc47 git status command is your window into the current state of your Git repository. It provides a clear picture of what's happening with your files, helping you understand which changes are tracked, staged, and untracked. Basic Usage \u27a1\ufe0f git status Shortened Status \u27a1\ufe0f git status -s Untracked Files \u27a1\ufe0f git status --untracked-files=all More Options --porcelain \u27a1\ufe0f Provides machine-readable output suitable for scripting. --branch \u27a1\ufe0f Shows the current branch and any tracking information. --long \u27a1\ufe0f Offers a more detailed status report, including the exact changes made to modified files. git commit \ud83d\udc47 git commit command is fundamental in Git for capturing snapshots of your project's history. It creates a new commit object that stores the current state of your tracked files along with a descriptive message. Basic Usage \u27a1\ufe0f git commit Specifying Commit Message \u27a1\ufe0f git commit -m \"Your commit message here\" Committing All Staged Changes \u27a1\ufe0f git commit -a Amending the Last Commit \u27a1\ufe0f git commit --amend get additional changes to a not pushed commit \u27a1\ufe0f git commit \u2013amend \u2013a Adding Untracked Files \u27a1\ufe0f git commit -m \"Your message\" new_file.txt More Options --date=<date> \u27a1\ufe0f Sets the commit date explicitly. --no-verify \u27a1\ufe0f Bypasses pre-commit hooks (if configured). Use with caution. --signoff \u27a1\ufe0f Adds a GPG signature to the commit. git push \ud83d\udc47 git push command is used to upload local commits to a remote repository. It's the counterpart to git fetch (downloading changes) and often used after you've made and committed changes locally. Basic Push \u27a1\ufe0f git push origin main Pushing Specific Branch \u27a1\ufe0f git push origin main Force Push \u27a1\ufe0f git push origin main --force Pushing Tags \u27a1\ufe0f git push origin <tag_name> More Options -u \u27a1\ufe0f Sets the upstream branch for your current local branch. This simplifies future pushes as you won't need to specify the branch name each time. --dry-run \u27a1\ufe0f Simulates the push process without making any actual changes. Useful for verifying what would be pushed. --delete \u27a1\ufe0f Deletes a remote branch after pushing if it has been deleted locally push commits to server \u27a1\ufe0f git push origin HEAD:<branch_name> git log \ud83d\udc47 git log command is your historian in the world of Git. It unveils the chronological record of your project's development by displaying a list of commits. Basic Usage \u27a1\ufe0f git log Show a one-line summary for each commit \u27a1\ufe0f git log --oneline Show visual representation of the commit history using ASCII art \u27a1\ufe0f git log --graph define a custom format for the commit messages using placeholders \u27a1\ufe0f git log --pretty=format:<custom_format> print latest commit ID \u27a1\ufe0f git log -1 --format=%H Filtering Commits Limiting Output \u27a1\ufe0f git log -n <number> history of last 3 commit \u27a1\ufe0f git log -3 Author Filtering \u27a1\ufe0f git log --author=\"John Doe\" Grepping Commit Messages \u27a1\ufe0f git log -S\"<search_term>\" Range Selection \u27a1\ufe0f git log <commit_hash1>..<commit_hash2> print commits merged between two commits \u27a1\ufe0f git log --oneline 1223344556677890897867453423122334456778..6523456789236734562354237856345634567890 More Options --all \u27a1\ufe0f Shows commits from all branches, not just the current one. --topo-order \u27a1\ufe0f Displays commits in a topological order (useful for complex branching). --stat \u27a1\ufe0f Includes statistics about file changes in each commit. git rebase \ud83d\udc47 Git rebase is a powerful tool for rewriting your commit history. It replays a series of commits on top of a new base commit. Basic Rebase \u27a1\ufe0f git rebase <branch_name> Interactive Rebase \u27a1\ufe0f git rebase -i <branch_name> More Options --onto <upstream> <branch_name> \u27a1\ufe0f Rebases your current branch onto a specific upstream branch, useful for complex branching scenarios. --keep-base \u27a1\ufe0f Maintains the original base commit of your branch instead of rebasing on top of the specified branch. rebasing steps git fetch git rebase <branch_name> if any conflicts during rebase, then resolve and execute below comments git add . git rebase --continue git push --force-with-lease origin HEAD git stash \ud83d\udc47 git stash command acts as a temporary storage locker for your local changes in Git. It allows you to save your uncommitted work (modified files, staged changes, and even untracked files) on a stack for later retrieval, effectively taking a snapshot of your current working directory. Basic Usage \u27a1\ufe0f git stash Creating Stashes with Message \u27a1\ufe0f git stash \"Meaningful message\" Include Untracked Files \u27a1\ufe0f git stash --include-untracked Retrieving a Stash Apply (Without Removing from Stash Stack) \u27a1\ufe0f git stash apply <stash_id> git stash apply \u27a1\ufe0f to apply the most recent stash. Pop (Apply and Remove from Stash Stack) \u27a1\ufe0f git stash pop <stash_id> Listing Stashes \u27a1\ufe0f git stash list More Options --keep-index \u27a1\ufe0f Keeps the staged changes in the index even after stashing. This can be useful if you want to keep them staged while working on something else. --show \u27a1\ufe0f Shows the details of a specific stash, including the diff of the changes it contains. --drop \u27a1\ufe0f Removes a stash from the stash stack without applying it. git stash show \u27a1\ufe0f to see what n is in the below commands. git stash apply stash@{n} \u27a1\ufe0f to apply an older stash. git clean and git reset \ud83d\udc47 clean repository \u27a1\ufe0f git clean -xffd reset repository \u27a1\ufe0f git reset --hard discard modified files and remove untracked files \u27a1\ufe0f git reset --hard && git clean -f -d remove last commit or uncommit last commit \u27a1\ufe0f git reset --hard HEAD~1 git submodule \ud83d\udc47 add submodule \u27a1\ufe0f git submodule add https://github.com/chaitu-ycr/git_notes.git add submodule in specific path \u27a1\ufe0f git submodule add https://github.com/chaitu-ycr/git_notes.git path_to_store_submodule force update submodules recursively \u27a1\ufe0f git submodule update --init --recursive --force clean submodule recursively \u27a1\ufe0f git submodule foreach --recursive git clean -xffd reset submodule recursively \u27a1\ufe0f git submodule foreach --recursive git reset --hard remove submodule remove the submodule entry from .git/config \u27a1\ufe0f git submodule deinit -f path/to/submodule remove the submodule directory from the superproject's .git/modules directory \u27a1\ufe0f rm -rf .git/modules/path/to/submodule remove the entry in .gitmodules and remove the submodule directory located at path/to/submodule \u27a1\ufe0f git rm -f path/to/submodule create/remove git tag \ud83d\udc47 git tag command is used to create lightweight or annotated tags that act as bookmarks for specific points in your commit history. Creating Tags Lightweight Tag (Reference to a Commit) \u27a1\ufe0f git tag <tag_name> <commit_hash> Annotated Tag (With Message and Signature) \u27a1\ufe0f git tag -m \"Your message here\" <tag_name> Listing Tags \u27a1\ufe0f git tag Viewing Tag Details \u27a1\ufe0f git show <tag_name> Deleting Tags \u27a1\ufe0f git tag -d <tag_name> delete the old tag from remote origin \u27a1\ufe0f git push origin :refs/tags/<tagname> Pushing Tags to Remote Repository \u27a1\ufe0f git push origin <tag_name> push all new local tags to remote \u27a1\ufe0f git push origin --tags More Options -l \u27a1\ufe0f Lists tags with additional information like the tag message (useful with git tag ). --verify \u27a1\ufe0f Verifies the GPG signature of an annotated tag (if applicable). --signed \u27a1\ufe0f Creates a signed tag using your GPG key by default (shortcut for -s ). git cherry-pick git cherry-pick command allows you to selectively apply specific commits from one branch to another branch in Git. It essentially \"picks\" a commit from a branch and grafts it onto your current branch, creating a new commit in your current branch history. Basic Usage \u27a1\ufe0f git cherry-pick <commit_hash> Resolving Merge Conflicts If conflicts arise, Git will halt the cherry-pick process and present you with the conflicting parts of the code. You'll need to manually resolve these conflicts using your text editor and then stage the resolved files using git add before continuing with git cherry-pick --continue . Cherry-pick with Commit Message Editing \u27a1\ufe0f git cherry-pick -e <commit_hash> Skipping Conflicts \u27a1\ufe0f git cherry-pick --skip <commit_hash> increase push/pull timeouts \ud83d\udc47 git config lfs.dialtimeout 3600 git config lfs.activitytimeout 3600 git config lfs.tlstimeout 3600 git config lfs.keepalive 3600 other useful git commands \ud83d\udc47 open a graphical user interface showing only the mainline you are working \u27a1\ufe0f gitk open a graphical user interface showing all branches \u27a1\ufe0f gitk --all compare your current changes on workspace (which are not committed yet) to the latest commit \u27a1\ufe0f git difftool if you want to compare the changes between 2 commits use \u27a1\ufe0f git difftool <commit id 1> < commit id 2>","title":"git_notes"},{"location":"#git_notes","text":"","title":"git_notes"},{"location":"#git_notes_1","text":"","title":"git_notes"},{"location":"#git-configuration","text":"Git configuration allows you to personalize how Git works for you. It's like setting preferences for any other software. There's a command called git config that lets you set and view these settings. check your current configuration \u27a1\ufe0f git config --list configure email and name globally email id \u27a1\ufe0f git config --global user.email \"enter email id\" user name \u27a1\ufe0f git config --global user.name \"enter your name\" add notepad++ as a global text editor \u27a1\ufe0f git config --global core.editor notepad++","title":"git configuration \ud83d\udc47"},{"location":"#ssh-key-generation","text":"generating SSH keys is a crucial step for using Git over SSH to securely connect to remote repositories like GitHub or GitLab. ssh-keygen -t rsa -C \"enter email id\" ssh-keygen This is the command to generate the SSH key pair. -t ed25519 This specifies the key type. Ed25519 is a modern and secure option. You can use -t rsa -b 4096 for RSA keys if your Git provider requires it, but Ed25519 is generally preferred. -C \"your_email@example.com\" This adds a comment to your key with your email address. This is helpful for identification. command will generate two keys A private key (usually named id_rsa ) - This key should be kept confidential and never shared. A public key (usually named id_rsa.pub ) - You'll need to add this public key to your Git provider account.","title":"ssh key generation \ud83d\udc47"},{"location":"#clone-repository","text":"git clone command is your gateway to creating a local copy, or clone, of a remote Git repository. basic syntax \u27a1\ufe0f git clone [url] [directory_name] git clone https://github.com/chaitu-ycr/git_notes.git other options clone to a specific path git clone https://github.com/chaitu-ycr/git_notes.git <user_defined_repo_path> Clone a specific branch use the -b flag to specify a particular branch to clone instead of the default branch. git clone -b <branch_name> https://github.com/chaitu-ycr/git_notes.git <user_defined_repo_path> Clone with mirror. --mirror flag creates a local copy that reflects all branches and tags from the remote repository. This is useful for making a complete backup. git clone --mirror https://github.com/chaitu-ycr/git_notes.git Sparse clone --sparse flag creates a lightweight clone that downloads only the minimum information needed to checkout a specific commit. This can save disk space. git clone --sparse https://github.com/chaitu-ycr/git_notes.git","title":"clone repository \ud83d\udc47"},{"location":"#git-checkout","text":"git checkout command is a versatile tool in Git with several functionalities Switching Branches switch between different branches in your local repository git checkout <branch_name> Detaching the HEAD use the -d flag to detach the HEAD git checkout -d <branch_name> Creating a New Branch \u27a1\ufe0f git checkout -b <new_branch_name> Restoring a File \u27a1\ufe0f git checkout <commit_hash> <file_path> Checkout with Checkout Index Checkout all staged files \u27a1\ufe0f git checkout Checkout a specific staged file \u27a1\ufe0f git checkout <file_path>","title":"git checkout \ud83d\udc47"},{"location":"#git-branch","text":"Listing Branches \u27a1\ufe0f git branch show all remote tracking branches \u27a1\ufe0f git branch \u2013a list the branches with additional information \u27a1\ufe0f git branch \u2013v only show merged branches \u27a1\ufe0f git branch \u2013m Creating a New Branch \u27a1\ufe0f git checkout -b <new_branch_name> Deleting a Branch \u27a1\ufe0f git branch -d <branch_name> Renaming a Branch \u27a1\ufe0f git branch -m <old_branch_name> <new_branch_name> Merging Branches \u27a1\ufe0f git merge <branch_name>","title":"git branch \ud83d\udc47"},{"location":"#git-fetch","text":"git fetch \u27a1\ufe0f downloads updates from a remote repository without merging them into your local working directory. command is essential for staying up-to-date in Git workflows. git fetch <remote> <branchname> Basic Fetch \u27a1\ufe0f git fetch origin Fetching Specific Branch \u27a1\ufe0f git fetch origin main Pruning Stale Tracking Branches \u27a1\ufe0f git fetch --prune origin Fetches from all configured remotes \u27a1\ufe0f git fetch --all Fetches only tags \u27a1\ufe0f git fetch --tags Limits the fetch to a specific number of commits \u27a1\ufe0f git fetch --depth=<number> Shows what would be fetched without making any changes \u27a1\ufe0f git fetch --dry-run","title":"git fetch \ud83d\udc47"},{"location":"#git-pull","text":"git pull command is a convenient shortcut that combines the functionality of git fetch and git merge in a single step. git pull [<remote>] [<branchname>] Basic Usage \u27a1\ufe0f git pull origin Specifying Branch \u27a1\ufe0f git pull origin main - It's generally a good practice to run git fetch first to see what changes are available before using git pull to avoid unintended merges. More Options --rebase \u27a1\ufe0f Rebases your local commits on top of the remote branch instead of creating a merge commit. This can lead to a cleaner commit history but can be risky if you've already shared your local branch. --force \u27a1\ufe0f Forces the merge even if there are local uncommitted changes. This can be dangerous and should be used with caution. --all \u27a1\ufe0f Fetches from all configured remotes.","title":"git pull \ud83d\udc47"},{"location":"#git-add","text":"git add command is your gateway to including changes in your Git repository. It instructs Git to prepare specific files or directories for the next commit. Basic Usage \u27a1\ufe0f git add <filename> Adding Multiple Files Explicit Listing \u27a1\ufe0f git add file1.txt file2.txt file3.js Using Wildcards \u27a1\ufe0f git add *.txt Adding All Staged Changes \u27a1\ufe0f git add . Adding All Changes (Staged and Unstaged) \u27a1\ufe0f git add -A More Options -f \u27a1\ufe0f Forces adding files even if they are ignored by Git. Use with caution as it bypasses exclusion rules. -p \u27a1\ufe0f Patches the content of a file interactively, allowing line-by-line staging of changes. -u \u27a1\ufe0f Updates the index with only the latest changes in a file, effectively refreshing the staged content. create or add new files \u27a1\ufe0f git add <new filename>","title":"git add \ud83d\udc47"},{"location":"#git-status","text":"git status command is your window into the current state of your Git repository. It provides a clear picture of what's happening with your files, helping you understand which changes are tracked, staged, and untracked. Basic Usage \u27a1\ufe0f git status Shortened Status \u27a1\ufe0f git status -s Untracked Files \u27a1\ufe0f git status --untracked-files=all More Options --porcelain \u27a1\ufe0f Provides machine-readable output suitable for scripting. --branch \u27a1\ufe0f Shows the current branch and any tracking information. --long \u27a1\ufe0f Offers a more detailed status report, including the exact changes made to modified files.","title":"git status \ud83d\udc47"},{"location":"#git-commit","text":"git commit command is fundamental in Git for capturing snapshots of your project's history. It creates a new commit object that stores the current state of your tracked files along with a descriptive message. Basic Usage \u27a1\ufe0f git commit Specifying Commit Message \u27a1\ufe0f git commit -m \"Your commit message here\" Committing All Staged Changes \u27a1\ufe0f git commit -a Amending the Last Commit \u27a1\ufe0f git commit --amend get additional changes to a not pushed commit \u27a1\ufe0f git commit \u2013amend \u2013a Adding Untracked Files \u27a1\ufe0f git commit -m \"Your message\" new_file.txt More Options --date=<date> \u27a1\ufe0f Sets the commit date explicitly. --no-verify \u27a1\ufe0f Bypasses pre-commit hooks (if configured). Use with caution. --signoff \u27a1\ufe0f Adds a GPG signature to the commit.","title":"git commit \ud83d\udc47"},{"location":"#git-push","text":"git push command is used to upload local commits to a remote repository. It's the counterpart to git fetch (downloading changes) and often used after you've made and committed changes locally. Basic Push \u27a1\ufe0f git push origin main Pushing Specific Branch \u27a1\ufe0f git push origin main Force Push \u27a1\ufe0f git push origin main --force Pushing Tags \u27a1\ufe0f git push origin <tag_name> More Options -u \u27a1\ufe0f Sets the upstream branch for your current local branch. This simplifies future pushes as you won't need to specify the branch name each time. --dry-run \u27a1\ufe0f Simulates the push process without making any actual changes. Useful for verifying what would be pushed. --delete \u27a1\ufe0f Deletes a remote branch after pushing if it has been deleted locally push commits to server \u27a1\ufe0f git push origin HEAD:<branch_name>","title":"git push \ud83d\udc47"},{"location":"#git-log","text":"git log command is your historian in the world of Git. It unveils the chronological record of your project's development by displaying a list of commits. Basic Usage \u27a1\ufe0f git log Show a one-line summary for each commit \u27a1\ufe0f git log --oneline Show visual representation of the commit history using ASCII art \u27a1\ufe0f git log --graph define a custom format for the commit messages using placeholders \u27a1\ufe0f git log --pretty=format:<custom_format> print latest commit ID \u27a1\ufe0f git log -1 --format=%H Filtering Commits Limiting Output \u27a1\ufe0f git log -n <number> history of last 3 commit \u27a1\ufe0f git log -3 Author Filtering \u27a1\ufe0f git log --author=\"John Doe\" Grepping Commit Messages \u27a1\ufe0f git log -S\"<search_term>\" Range Selection \u27a1\ufe0f git log <commit_hash1>..<commit_hash2> print commits merged between two commits \u27a1\ufe0f git log --oneline 1223344556677890897867453423122334456778..6523456789236734562354237856345634567890 More Options --all \u27a1\ufe0f Shows commits from all branches, not just the current one. --topo-order \u27a1\ufe0f Displays commits in a topological order (useful for complex branching). --stat \u27a1\ufe0f Includes statistics about file changes in each commit.","title":"git log \ud83d\udc47"},{"location":"#git-rebase","text":"Git rebase is a powerful tool for rewriting your commit history. It replays a series of commits on top of a new base commit. Basic Rebase \u27a1\ufe0f git rebase <branch_name> Interactive Rebase \u27a1\ufe0f git rebase -i <branch_name> More Options --onto <upstream> <branch_name> \u27a1\ufe0f Rebases your current branch onto a specific upstream branch, useful for complex branching scenarios. --keep-base \u27a1\ufe0f Maintains the original base commit of your branch instead of rebasing on top of the specified branch. rebasing steps git fetch git rebase <branch_name> if any conflicts during rebase, then resolve and execute below comments git add . git rebase --continue git push --force-with-lease origin HEAD","title":"git rebase \ud83d\udc47"},{"location":"#git-stash","text":"git stash command acts as a temporary storage locker for your local changes in Git. It allows you to save your uncommitted work (modified files, staged changes, and even untracked files) on a stack for later retrieval, effectively taking a snapshot of your current working directory. Basic Usage \u27a1\ufe0f git stash Creating Stashes with Message \u27a1\ufe0f git stash \"Meaningful message\" Include Untracked Files \u27a1\ufe0f git stash --include-untracked Retrieving a Stash Apply (Without Removing from Stash Stack) \u27a1\ufe0f git stash apply <stash_id> git stash apply \u27a1\ufe0f to apply the most recent stash. Pop (Apply and Remove from Stash Stack) \u27a1\ufe0f git stash pop <stash_id> Listing Stashes \u27a1\ufe0f git stash list More Options --keep-index \u27a1\ufe0f Keeps the staged changes in the index even after stashing. This can be useful if you want to keep them staged while working on something else. --show \u27a1\ufe0f Shows the details of a specific stash, including the diff of the changes it contains. --drop \u27a1\ufe0f Removes a stash from the stash stack without applying it. git stash show \u27a1\ufe0f to see what n is in the below commands. git stash apply stash@{n} \u27a1\ufe0f to apply an older stash.","title":"git stash \ud83d\udc47"},{"location":"#git-clean-and-git-reset","text":"clean repository \u27a1\ufe0f git clean -xffd reset repository \u27a1\ufe0f git reset --hard discard modified files and remove untracked files \u27a1\ufe0f git reset --hard && git clean -f -d remove last commit or uncommit last commit \u27a1\ufe0f git reset --hard HEAD~1","title":"git clean and git reset \ud83d\udc47"},{"location":"#git-submodule","text":"add submodule \u27a1\ufe0f git submodule add https://github.com/chaitu-ycr/git_notes.git add submodule in specific path \u27a1\ufe0f git submodule add https://github.com/chaitu-ycr/git_notes.git path_to_store_submodule force update submodules recursively \u27a1\ufe0f git submodule update --init --recursive --force clean submodule recursively \u27a1\ufe0f git submodule foreach --recursive git clean -xffd reset submodule recursively \u27a1\ufe0f git submodule foreach --recursive git reset --hard remove submodule remove the submodule entry from .git/config \u27a1\ufe0f git submodule deinit -f path/to/submodule remove the submodule directory from the superproject's .git/modules directory \u27a1\ufe0f rm -rf .git/modules/path/to/submodule remove the entry in .gitmodules and remove the submodule directory located at path/to/submodule \u27a1\ufe0f git rm -f path/to/submodule","title":"git submodule \ud83d\udc47"},{"location":"#createremove-git-tag","text":"git tag command is used to create lightweight or annotated tags that act as bookmarks for specific points in your commit history. Creating Tags Lightweight Tag (Reference to a Commit) \u27a1\ufe0f git tag <tag_name> <commit_hash> Annotated Tag (With Message and Signature) \u27a1\ufe0f git tag -m \"Your message here\" <tag_name> Listing Tags \u27a1\ufe0f git tag Viewing Tag Details \u27a1\ufe0f git show <tag_name> Deleting Tags \u27a1\ufe0f git tag -d <tag_name> delete the old tag from remote origin \u27a1\ufe0f git push origin :refs/tags/<tagname> Pushing Tags to Remote Repository \u27a1\ufe0f git push origin <tag_name> push all new local tags to remote \u27a1\ufe0f git push origin --tags More Options -l \u27a1\ufe0f Lists tags with additional information like the tag message (useful with git tag ). --verify \u27a1\ufe0f Verifies the GPG signature of an annotated tag (if applicable). --signed \u27a1\ufe0f Creates a signed tag using your GPG key by default (shortcut for -s ).","title":"create/remove git tag \ud83d\udc47"},{"location":"#git-cherry-pick","text":"git cherry-pick command allows you to selectively apply specific commits from one branch to another branch in Git. It essentially \"picks\" a commit from a branch and grafts it onto your current branch, creating a new commit in your current branch history. Basic Usage \u27a1\ufe0f git cherry-pick <commit_hash> Resolving Merge Conflicts If conflicts arise, Git will halt the cherry-pick process and present you with the conflicting parts of the code. You'll need to manually resolve these conflicts using your text editor and then stage the resolved files using git add before continuing with git cherry-pick --continue . Cherry-pick with Commit Message Editing \u27a1\ufe0f git cherry-pick -e <commit_hash> Skipping Conflicts \u27a1\ufe0f git cherry-pick --skip <commit_hash>","title":"git cherry-pick"},{"location":"#increase-pushpull-timeouts","text":"git config lfs.dialtimeout 3600 git config lfs.activitytimeout 3600 git config lfs.tlstimeout 3600 git config lfs.keepalive 3600","title":"increase push/pull timeouts \ud83d\udc47"},{"location":"#other-useful-git-commands","text":"open a graphical user interface showing only the mainline you are working \u27a1\ufe0f gitk open a graphical user interface showing all branches \u27a1\ufe0f gitk --all compare your current changes on workspace (which are not committed yet) to the latest commit \u27a1\ufe0f git difftool if you want to compare the changes between 2 commits use \u27a1\ufe0f git difftool <commit id 1> < commit id 2>","title":"other useful git commands \ud83d\udc47"}]}